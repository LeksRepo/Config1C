
Функция МаксимальноеЗначениеВМассиве(фМассив)
	
	тз = Новый ТаблицаЗначений;
	тз.Колонки.Добавить("Значение");
	
	Для каждого Элемент Из фМассив Цикл
		тз.Добавить();
	КонецЦикла;
	
	тз.ЗагрузитьКолонку(фМассив, "Значение");
	тз.Сортировать("Значение Убыв");
	
	Возврат тз[0].Значение;
	
КонецФункции

Функция ПрименитьТолщинуРеза(МассивЭлементов, МаксимальнаяСумма, Дельта)
	
	// { Васильев Александр Леонидович [15.01.2016]
	// Для учета последнего реза.
	// Т.к. делать его не нужно.
	МаксимальнаяСумма = МаксимальнаяСумма + Дельта;
	// } Васильев Александр Леонидович [15.01.2016]
	
	
	Для Индекс = 1 По МассивЭлементов.ВГраница() Цикл
		
		МассивЭлементов[Индекс] = МассивЭлементов[Индекс] + Дельта;
		
	КонецЦикла;
	
КонецФункции

Функция МодульЧисла(фЧисло)
	
	Если фЧисло >= 0 Тогда
		Результат = фЧисло;
	Иначе
		Результат = -фЧисло;
	КонецЕсли;
	
	Возврат Результат;
	
КонецФункции

Функция ОбщаяДлинаЭлементов(Массив, УвеличениеЭлемента = 0)
	
	Результат = 0;
	
	Для каждого Элемент Из Массив Цикл
		
		Результат = Результат + Элемент + УвеличениеЭлемента;
		
	КонецЦикла;
	
	// Вычитаем последний пил
	Результат = Результат- УвеличениеЭлемента;
	
	Возврат Результат;
	
КонецФункции

Функция МаксимальнаяСуммаПодмножеств(МассивЭлементов, Знач МаксимальнаяСумма, УвеличениеЭлемента = 0) Экспорт
	
	Результат = Новый Структура;
	Результат.Вставить("Массив", Новый Массив);
	Результат.Вставить("Сумма");
	Результат.Вставить("МинимальныйОстаток");
	Результат.Вставить("КоличествоЭлементов");
	Результат.Вставить("ОбщаяДлинаПила");
	
	МаксимальныйЭлемент = МаксимальноеЗначениеВМассиве(МассивЭлементов);
	Если МаксимальныйЭлемент > МаксимальнаяСумма Тогда
		ВызватьИсключение "Ошибка 773: Элемент размера " + МаксимальныйЭлемент +" превышает максимум в " + МаксимальнаяСумма;
	КонецЕсли;
	
	// В таблице нулевые строки и колонки -- служебные.
	// Скопируем нулевую строку в конец, исходник обнулим.
	
	МассивЭлементов.Добавить(МассивЭлементов[0]);
	МассивЭлементов[0] = 0;
	
	КоличествоЭлементов = МассивЭлементов.ВГраница();
	
	// Обработка толщины реза
	// Увеличим каждый элемент
	// и максимальную сумму (для учета одного последнего реза)
	Если УвеличениеЭлемента <> 0 Тогда
		
		// Сохраним исходный массив, чтобы не отнимать толщину пила
		// если обрезков недостаточно на целый хлыст
		ОригинальныйМассив = ОбщегоНазначенияКлиентСервер.СкопироватьМассив(МассивЭлементов);
		ПрименитьТолщинуРеза(МассивЭлементов, МаксимальнаяСумма, УвеличениеЭлемента);
		
	КонецЕсли;
	
	// Проверка общей суммы на превышение длины хлыста.
	// Нет смысла включать алгоритм если все элементы и так помещаются.
	СуммаДлин = ОбщаяДлинаЭлементов(МассивЭлементов);
	Если СуммаДлин < МаксимальнаяСумма Тогда
		
		Если ЗначениеЗаполнено(ОригинальныйМассив) Тогда
			Результат.Массив = ОригинальныйМассив;
		Иначе
			Результат.Массив = ОбщегоНазначенияКлиентСервер.СкопироватьМассив(МассивЭлементов);
		КонецЕсли;
		
		МассивЭлементов.Удалить(0);
		Результат.Массив.Удалить(0);
		
		Результат.Сумма = СуммаДлин - УвеличениеЭлемента * КоличествоЭлементов;
		Результат.МинимальныйОстаток = МаксимальнаяСумма - УвеличениеЭлемента - СуммаДлин;
		Результат.КоличествоЭлементов = КоличествоЭлементов;
		Результат.ОбщаяДлинаПила = КоличествоЭлементов * УвеличениеЭлемента + УвеличениеЭлемента;
		
		Возврат Результат;
		
	КонецЕсли;
	
	////////////////////////////////
	// Основной алгоритм распределения
	
	// Подготовка рабочей таблицы.
	
	Т = Новый Массив(КоличествоЭлементов + 1, МаксимальнаяСумма + 1);
	
	Для Индекс = 1 По МаксимальнаяСумма Цикл
		Т[0][Индекс] = 0;
	КонецЦикла;
	
	Для Индекс = 0 По КоличествоЭлементов Цикл
		Т[Индекс][0] = 1;
	КонецЦикла;
	
	// Формирование матрицы решений.
	
	Для ИтераторЭлемента = 1 По КоличествоЭлементов Цикл
		
		Для ИтераторРазмера = 1 По МаксимальнаяСумма Цикл
			
			Если ИтераторРазмера >= МассивЭлементов[ИтераторЭлемента] Тогда
				
				Если Т[ИтераторЭлемента - 1][ИтераторРазмера] > Т[ИтераторЭлемента - 1][ИтераторРазмера - МассивЭлементов[ИтераторЭлемента]] Тогда
					
					Т[ИтераторЭлемента][ИтераторРазмера] = Т[ИтераторЭлемента - 1][ИтераторРазмера];
					
				Иначе
					
					Т[ИтераторЭлемента][ИтераторРазмера] = Т[ИтераторЭлемента - 1][ИтераторРазмера - МассивЭлементов[ИтераторЭлемента]];
					
				КонецЕсли;
				
			Иначе
				
				Т[ИтераторЭлемента][ИтераторРазмера] = Т[ИтераторЭлемента - 1][ИтераторРазмера];
				
			КонецЕсли;
			
		КонецЦикла;
		
	КонецЦикла;
	
	// Выбор оптимального решения.
	
	Сумма = 0;
	МинимальныйОстаток = МаксимальнаяСумма;
	
	Для Итератор = 0 По МаксимальнаяСумма - 1 Цикл
		
		РазмерЭлемента = МаксимальнаяСумма - Итератор;
		
		Если Т[КоличествоЭлементов][РазмерЭлемента] = 1 Тогда
			
			Если МинимальныйОстаток > МодульЧисла(МаксимальнаяСумма - РазмерЭлемента) Тогда
				МинимальныйОстаток = МодульЧисла(МаксимальнаяСумма - РазмерЭлемента);
				Сумма = РазмерЭлемента;
			КонецЕсли;
			
		КонецЕсли;
		
	КонецЦикла;
	
	// Определение результата
	
	Результат.Сумма = Сумма;
	
	Для Итератор = 0 По КоличествоЭлементов - 1 Цикл
		
		НомерЭлемента = КоличествоЭлементов - Итератор;
		
		Если Т[НомерЭлемента][Сумма] <> Т[НомерЭлемента - 1][Сумма] Тогда
			Результат.Массив.Добавить(МассивЭлементов[НомерЭлемента] - УвеличениеЭлемента);
			Сумма = Сумма - МассивЭлементов[НомерЭлемента];
		КонецЕсли;
		
	КонецЦикла;
	
	// Уменьшим результат на сумму пилов.
	Результат.Сумма = Результат.Сумма - УвеличениеЭлемента * Результат.Массив.Количество();
	РазмещеноЭлементов = Результат.Массив.Количество();
	Результат.МинимальныйОстаток = МаксимальнаяСумма - Результат.Сумма - УвеличениеЭлемента * (РазмещеноЭлементов + 1);
	
	МассивЭлементов.Удалить(0);
	
	Возврат Результат;
	
КонецФункции
